package soen.game.dd.logic;

import java.awt.Point;

import soen.game.dd.models.Map;
import soen.game.dd.statics.content.GameEnums.E_MapValidationDirecton;
import soen.game.dd.statics.content.GameStatics;

/**
 * This class validates map features(Entry,Exit) and map path from the root
 * 
 * @author Usman
 * 
 */
public class MapValidation {

	/**
	 * This method validates the map
	 * 
	 * @param new_mapModel
	 *            as a map
	 * @return the routeStatus
	 */
	public String mapValidations(Map new_mapModel) {
		String routeStatus = null;
		if (!new_mapModel.isEntryDone || new_mapModel.getEntryPoint() == null) {
			routeStatus = "Please First Select an Entry Point.";
			new_mapModel.setMapAutoGeneratedDescription(routeStatus);
		}

		else if (!new_mapModel.isExitDone || new_mapModel.getExitPoint() == null) {
			routeStatus = "Please First Select an Exit Point.";
			new_mapModel.setMapAutoGeneratedDescription(routeStatus);
		}

		else if (!new_mapModel.isChestDone) {
			routeStatus = "Please first added chest items";
			new_mapModel.setMapAutoGeneratedDescription(routeStatus);
		}

		else {
			routeStatus = mapPathValidation(new_mapModel);
			if (routeStatus.contains("Success")) {
				new_mapModel.setMapAutoGeneratedDescription(routeStatus);
				routeStatus = null;
			} else {
				new_mapModel.setMapAutoGeneratedDescription(routeStatus);
			}
		}

		return routeStatus;

	}

	/**
	 * This method validates the map path
	 * 
	 * @param new_map
	 *            the map
	 * 
	 * @return the status of the map verified or not-verified
	 */
	public String mapPathValidation(Map new_map) {
		int mapWidth = new_map.getMapWidth();
		int mapHeight = new_map.getMapHeight();
		Point entryPoint = new_map.getEntryPoint();
		int mapPathCellCount = 1;// for Entry Point
		String status = "Error:Cells:Incorrect Map";
		int i = entryPoint.x;
		int j = entryPoint.y;
		E_MapValidationDirecton dirUpDown = E_MapValidationDirecton.Initial;

		int predictiveConnectedCellCount;
		GameStatics.MAP_ROUT_PATH = "" + i + "," + j + ";";

		while ((i >= 0 && i < mapHeight) || (j >= 0 && j < mapWidth)) {
			predictiveConnectedCellCount = 0;
			int cellValue = 0;
			int connectedCellFound = 0;

			// Checking For Up Cell
			if (i >= 0 && ((dirUpDown == E_MapValidationDirecton.Initial || dirUpDown == E_MapValidationDirecton.Up)
					&& new_map.getExitPoint().getX() < new_map.getEntryPoint().getX())) {

				cellValue = new_map.getMapGridSelection()[i - 1][j];
				if (cellValue == GameStatics.MAP_PATH_POINT || cellValue == GameStatics.MAP_ENTRY_POINT
						|| cellValue == GameStatics.MAP_CHEST_POINT || cellValue == GameStatics.MAP_CHARACTER_POINT
						|| cellValue == GameStatics.MAP_OPPONENT_POINT) {
					i--;
					mapPathCellCount++;
					connectedCellFound++;
					if (new_map.getExitPoint().getY() > j) {
						dirUpDown = E_MapValidationDirecton.Right;
					} else {
						dirUpDown = E_MapValidationDirecton.Left;
					}

					if (!GameStatics.MAP_ROUT_PATH.contains("" + i + "," + j + ";")) {
						GameStatics.MAP_ROUT_PATH += "" + i + "," + j + ";";
					}
				} else if (cellValue == GameStatics.MAP_EXIT_POINT) {
					dirUpDown = E_MapValidationDirecton.Up;
					if (mapPathCellCount <= 2) {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Error:Cells:" + mapPathCellCount
								+ ":Map is not correct has only Entry and Exit points.";
						break;
					} else {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Success:Cells:" + mapPathCellCount + "";
						break;
					}
				}
			}

			// Checking For Right Cell
			if (j >= 0
					&& (dirUpDown == E_MapValidationDirecton.Initial || dirUpDown == E_MapValidationDirecton.Right)) {

				cellValue = new_map.getMapGridSelection()[i][j + 1];
				if (cellValue == GameStatics.MAP_PATH_POINT || cellValue == GameStatics.MAP_ENTRY_POINT
						|| cellValue == GameStatics.MAP_CHEST_POINT || cellValue == GameStatics.MAP_CHARACTER_POINT
						|| cellValue == GameStatics.MAP_OPPONENT_POINT) {
					j++;
					mapPathCellCount++;
					connectedCellFound++;

					if (j >= new_map.getMapWidth() - 1
							|| new_map.getMapGridSelection()[i][j + 1] == GameStatics.MAP_WALL_POINT) {
						if (new_map.getExitPoint().getX() < new_map.getEntryPoint().getX()) {
							dirUpDown = E_MapValidationDirecton.Up;
						} else {
							dirUpDown = E_MapValidationDirecton.Down;
						}
					} else {
						dirUpDown = E_MapValidationDirecton.Right;
					}

					if (!GameStatics.MAP_ROUT_PATH.contains("" + i + "," + j + ";")) {
						GameStatics.MAP_ROUT_PATH += "" + i + "," + j + ";";
					}
				} else if (cellValue == GameStatics.MAP_EXIT_POINT) {
					dirUpDown = E_MapValidationDirecton.Right;
					if (mapPathCellCount <= 2) {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Error:Cells:" + mapPathCellCount
								+ ":Map is not correct has only Entry and Exit points.";
						break;
					} else {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Success:Cells:" + mapPathCellCount + "";
						break;
					}
				} else {
					if (new_map.getExitPoint().getX() < new_map.getEntryPoint().getX()) {
						dirUpDown = E_MapValidationDirecton.Up;
					} else {
						dirUpDown = E_MapValidationDirecton.Down;
					}
				}
			}

			// Checking for Left cell
			if (j < mapWidth
					&& (dirUpDown == E_MapValidationDirecton.Initial || dirUpDown == E_MapValidationDirecton.Left)) {
				cellValue = new_map.getMapGridSelection()[i][j - 1];
				if (cellValue == GameStatics.MAP_PATH_POINT || cellValue == GameStatics.MAP_ENTRY_POINT
						|| cellValue == GameStatics.MAP_CHEST_POINT || cellValue == GameStatics.MAP_CHARACTER_POINT
						|| cellValue == GameStatics.MAP_OPPONENT_POINT) {
					j--;
					mapPathCellCount++;
					connectedCellFound++;

					if (j <= 0 || new_map.getMapGridSelection()[i][j - 1] == GameStatics.MAP_WALL_POINT) {
						if (new_map.getExitPoint().getX() < new_map.getEntryPoint().getX()) {
							dirUpDown = E_MapValidationDirecton.Up;
						} else {
							dirUpDown = E_MapValidationDirecton.Down;
						}
					} else {
						dirUpDown = E_MapValidationDirecton.Left;
					}

					if (!GameStatics.MAP_ROUT_PATH.contains("" + i + "," + j + ";")) {
						GameStatics.MAP_ROUT_PATH += "" + i + "," + j + ";";
					} else {
						dirUpDown = E_MapValidationDirecton.Initial;
					}
				} else if (cellValue == GameStatics.MAP_EXIT_POINT) // Check
																	// if
																	// it
																	// is
																	// Exit
																	// point
				{
					dirUpDown = E_MapValidationDirecton.Left;
					if (mapPathCellCount <= 2) {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Error:Cells:" + mapPathCellCount
								+ ":Map is not correct has only Entry and Exit points.";
						break;
					} else {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Success:Cells:" + mapPathCellCount + "";
						break;
					}
				} else {
					if (new_map.getExitPoint().getX() < new_map.getEntryPoint().getX()) {
						dirUpDown = E_MapValidationDirecton.Up;
					} else {
						dirUpDown = E_MapValidationDirecton.Down;
					}
				}
			}

			// Checking for Down cell
			if (i < mapHeight
					&& (dirUpDown == E_MapValidationDirecton.Initial || dirUpDown == E_MapValidationDirecton.Down
							&& new_map.getExitPoint().getX() > new_map.getEntryPoint().getX())) {
				cellValue = new_map.getMapGridSelection()[i + 1][j];
				if (cellValue == GameStatics.MAP_PATH_POINT || cellValue == GameStatics.MAP_ENTRY_POINT
						|| cellValue == GameStatics.MAP_CHEST_POINT || cellValue == GameStatics.MAP_CHARACTER_POINT
						|| cellValue == GameStatics.MAP_OPPONENT_POINT) {
					i++;
					mapPathCellCount++;
					connectedCellFound++;
					if (new_map.getExitPoint().getY() > j) {
						dirUpDown = E_MapValidationDirecton.Right;
					} else {
						dirUpDown = E_MapValidationDirecton.Left;
					}

					if (!GameStatics.MAP_ROUT_PATH.contains("" + i + "," + j + ";")) {
						GameStatics.MAP_ROUT_PATH += "" + i + "," + j + ";";
					} else {
						dirUpDown = E_MapValidationDirecton.Initial;
					}
				}
				// Check if it is Exit point
				else if (cellValue == GameStatics.MAP_EXIT_POINT) {
					dirUpDown = E_MapValidationDirecton.Down;
					if (mapPathCellCount <= 2) {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Error:Cells:" + mapPathCellCount
								+ ":Map is not correct has only Entry and Exit points.";
						break;
					} else {
						mapPathCellCount++;
						connectedCellFound++;
						status = "Success:Cells:" + mapPathCellCount + "";
						break;
					}
				} else {
					if (new_map.getExitPoint().getX() < new_map.getEntryPoint().getX()) {
						dirUpDown = E_MapValidationDirecton.Up;
					} else {
						dirUpDown = E_MapValidationDirecton.Down;
					}
				}
			}
		}

		return status;
	}

	/**
	 * This method Check if there is any Independent or non connected cell on
	 * map
	 * 
	 * @param new_map
	 *            the map
	 * 
	 * 
	 * @return the boolean True if all cell is connected no independent cell
	 *         otherwise False
	 */
	public boolean checkIndependentSelectedCells(Map new_map) {
		boolean result = true;
		int mapWidth = new_map.getMapWidth();
		int mapHeight = new_map.getMapHeight();
		int value;
		for (int i = 0; i < mapHeight; i++) {
			for (int j = 0; j < mapWidth; j++) {
				value = new_map.getMapGridSelection()[i][j];
				if (value == GameStatics.MAP_PATH_POINT) {
					if (!GameStatics.MAP_ROUT_PATH.contains("" + i + "," + j + ";")) {
						return false;
					}
				}
			}
		}
		return result;
	}
}
